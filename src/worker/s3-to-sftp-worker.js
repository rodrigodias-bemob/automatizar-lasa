
const AWS = require('aws-sdk');
const ftp = require('basic-ftp');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { format } = require('date-fns');
const cron = require('node-cron');

// Configura√ß√µes - estas devem ser carregadas de um arquivo de configura√ß√£o
// ou vari√°veis de ambiente em um ambiente de produ√ß√£o
const config = {
  s3: {
    accessKey: process.env.S3_ACCESS_KEY,
    secretKey: process.env.S3_SECRET_KEY,
    bucket: process.env.S3_BUCKET || 'm4u-conciliation',
    region: process.env.S3_REGION || 'us-east-1',
    prefix: process.env.S3_PREFIX || 'lasa/inbound/',
  },
  ftp: {
    host: process.env.FTP_HOST,
    port: parseInt(process.env.FTP_PORT || '21'),
    username: process.env.FTP_USERNAME,
    password: process.env.FTP_PASSWORD,
    directory: process.env.FTP_DIRECTORY || '/put',
    secure: process.env.FTP_SECURE === 'true',
  },
  slack: {
    webhookUrl: process.env.SLACK_WEBHOOK_URL,
  },
  filePrefix: process.env.FILE_PREFIX || '2025',
  cronSchedule: process.env.CRON_SCHEDULE || '0 10 * * *', // Padr√£o: todos os dias √†s 10h
  runOnStart: process.env.RUN_ON_START === 'true' || true,  // Executa ao iniciar, por padr√£o
};

// Configura√ß√£o do cliente S3
const s3 = new AWS.S3({
  accessKeyId: config.s3.accessKey,
  secretAccessKey: config.s3.secretKey,
  region: config.s3.region,
});

// Fun√ß√£o para formatar a data atual ou uma data espec√≠fica
function formatDate(date = new Date()) {
  return format(date, 'yyyy-MM-dd');
}

// Fun√ß√£o para renomear o arquivo removendo o sufixo "_RECHARGE_REPORT"
function renameFile(fileName) {
  // Verifica se o nome do arquivo cont√©m "_RECHARGE_REPORT"
  if (fileName.includes('_RECHARGE_REPORT')) {
    // Remove o sufixo "_RECHARGE_REPORT" do nome do arquivo
    return fileName.replace('_RECHARGE_REPORT', '');
  }
  return fileName;
}

// Verifica se o arquivo do dia existe no S3
async function checkDailyFile() {
  const today = formatDate();
  // Usamos o prefixo configurado para buscar por qualquer arquivo que comece com esse prefixo
  const filePrefix = config.filePrefix;
  const s3Prefix = config.s3.prefix; // Prefixo do diret√≥rio no S3
  
  try {
    console.log(`Verificando exist√™ncia de arquivos que come√ßam com ${filePrefix} no bucket ${config.s3.bucket} no diret√≥rio ${s3Prefix}`);
    
    // Lista todos os arquivos no bucket com o prefixo do diret√≥rio e do arquivo
    const completePrefix = s3Prefix + filePrefix;
    const { Contents } = await s3.listObjects({ 
      Bucket: config.s3.bucket,
      Prefix: completePrefix
    }).promise();
    
    if (!Contents || Contents.length === 0) {
      console.log(`Nenhum arquivo encontrado com o prefixo ${completePrefix}`);
      await sendSlackAlert(`Nenhum arquivo encontrado com o prefixo ${completePrefix}`);
      return { 
        exists: false, 
        fileName: null 
      };
    }
    
    // Obt√©m o arquivo mais recente (assumindo que queremos o mais recente)
    const latestFile = Contents.sort((a, b) => 
      new Date(b.LastModified) - new Date(a.LastModified)
    )[0];
    
    if (latestFile) {
      console.log(`Arquivo mais recente encontrado: ${latestFile.Key}`);
      return { 
        exists: true, 
        fileName: latestFile.Key 
      };
    } else {
      console.log(`Nenhum arquivo v√°lido encontrado com o prefixo ${completePrefix}`);
      await sendSlackAlert(`Nenhum arquivo v√°lido encontrado com o prefixo ${completePrefix}`);
      return { 
        exists: false, 
        fileName: null 
      };
    }
  } catch (error) {
    console.error('Erro ao verificar arquivo no S3:', error);
    await sendSlackAlert(`Erro ao verificar arquivo no S3: ${error.message}`);
    throw error;
  }
}

// Fun√ß√£o para enviar mensagem ao Slack
async function sendSlackAlert(message) {
  if (!config.slack.webhookUrl) {
    console.log('URL do webhook do Slack n√£o configurada. Pulando notifica√ß√£o.');
    return;
  }
  
  try {
    console.log(`Enviando alerta para o Slack: ${message}`);
    
    await axios.post(config.slack.webhookUrl, {
      text: `[S3 para FTP] üö® ALERTA: ${message}`,
    });
    
    console.log('Notifica√ß√£o enviada com sucesso para o Slack');
  } catch (error) {
    console.error('Erro ao enviar notifica√ß√£o para o Slack:', error);
  }
}

// Baixa o arquivo do S3 e mant√©m em mem√≥ria (sem gravar em disco)
async function downloadFileFromS3(fileName) {
  try {
    console.log(`Baixando arquivo ${fileName} do bucket ${config.s3.bucket}`);
    
    const { Body } = await s3.getObject({
      Bucket: config.s3.bucket,
      Key: fileName,
    }).promise();
    
    console.log(`Arquivo baixado com sucesso`);
    
    return {
      buffer: Body,
      fileName: path.basename(fileName)
    };
  } catch (error) {
    console.error(`Erro ao baixar arquivo ${fileName} do S3:`, error);
    await sendSlackAlert(`Erro ao baixar arquivo ${fileName} do S3: ${error.message}`);
    throw error;
  }
}

// Envia o arquivo para o FTP usando um arquivo tempor√°rio
async function uploadFileToFtp(fileData, originalFileName) {
  const client = new ftp.Client();
  client.ftp.verbose = true;
  
  try {
    console.log(`Conectando ao servidor FTP: ${config.ftp.host}`);
    
    // Configurando o cliente FTP
    await client.access({
      host: config.ftp.host,
      port: config.ftp.port,
      user: config.ftp.username,
      password: config.ftp.password,
      secure: config.ftp.secure,
    });
    
    // Renomeia o arquivo antes de enviar para o FTP
    const renamedFileName = renameFile(path.basename(originalFileName));
    
    console.log(`Nome original do arquivo: ${originalFileName}`);
    console.log(`Nome do arquivo ap√≥s renomea√ß√£o: ${renamedFileName}`);
    
    // Cria um diret√≥rio tempor√°rio se n√£o existir
    const tempDir = path.join(__dirname, 'temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
      console.log(`Diret√≥rio tempor√°rio criado: ${tempDir}`);
    }
    
    // Caminho para o arquivo tempor√°rio
    const tempFilePath = path.join(tempDir, renamedFileName);
    console.log(`Criando arquivo tempor√°rio em: ${tempFilePath}`);
    
    // Grava o buffer em um arquivo tempor√°rio
    fs.writeFileSync(tempFilePath, fileData.buffer);
    const fileSizeBytes = fs.statSync(tempFilePath).size;
    console.log(`Arquivo tempor√°rio criado com tamanho: ${fileSizeBytes} bytes`);
    
    // Verifica o diret√≥rio atual
    const currentDir = await client.pwd();
    console.log(`Diret√≥rio atual no FTP: ${currentDir}`);
    
    // Define o diret√≥rio de trabalho (se especificado e diferente de '/')
    if (config.ftp.directory && config.ftp.directory !== '/' && config.ftp.directory !== currentDir) {
      try {
        await client.cd(config.ftp.directory);
        console.log(`Diret√≥rio alterado para: ${config.ftp.directory}`);
      } catch (dirError) {
        console.log(`Diret√≥rio ${config.ftp.directory} n√£o encontrado. Tentando criar...`);
        try {
          await client.ensureDir(config.ftp.directory);
          console.log(`Diret√≥rio ${config.ftp.directory} criado com sucesso`);
        } catch (mkdirError) {
          console.error(`Erro ao criar diret√≥rio: ${mkdirError.message}`);
          throw mkdirError;
        }
      }
    }
    
    // Upload do arquivo a partir do arquivo tempor√°rio
    console.log(`Iniciando upload do arquivo: ${tempFilePath} para o FTP como: ${renamedFileName}`);
    await client.uploadFrom(tempFilePath, renamedFileName);
    
    // Lista os arquivos no diret√≥rio atual para verificar o upload
    console.log('Verificando se o arquivo foi enviado:');
    const files = await client.list();
    const uploadedFile = files.find(file => file.name === renamedFileName);
    if (uploadedFile) {
      console.log(`Arquivo enviado confirmado: ${renamedFileName}, tamanho: ${uploadedFile.size} bytes`);
    } else {
      console.log(`Arquivo n√£o encontrado ap√≥s upload: ${renamedFileName}`);
    }
    
    // Remove o arquivo tempor√°rio ap√≥s o envio
    fs.unlinkSync(tempFilePath);
    console.log(`Arquivo tempor√°rio removido: ${tempFilePath}`);
    
    console.log(`Arquivo enviado com sucesso para o FTP como: ${renamedFileName}`);
    await sendSlackAlert(`‚úÖ Arquivo ${renamedFileName} transferido com sucesso para o FTP`);
    
    return {
      success: true,
      remotePath: `${config.ftp.directory}/${renamedFileName}`,
      originalName: originalFileName,
      renamedTo: renamedFileName
    };
  } catch (error) {
    console.error('Erro ao enviar arquivo para FTP:', error);
    await sendSlackAlert(`‚ùå Erro ao enviar arquivo para FTP: ${error.message}`);
    throw error;
  } finally {
    client.close();
    console.log('Conex√£o FTP encerrada');
  }
}

// Fun√ß√£o principal que orquestra todo o processo
async function transferDailyFileFromS3ToFtp() {
  console.log('Iniciando processo de transfer√™ncia S3 -> FTP');
  console.log(new Date().toISOString());
  
  try {
    // Verifica se o arquivo do dia existe
    const { exists, fileName } = await checkDailyFile();
    
    if (!exists || !fileName) {
      console.log('Arquivo di√°rio n√£o encontrado. Processo encerrado.');
      return {
        success: false,
        message: `Arquivo n√£o encontrado no S3`
      };
    }
    
    // Baixa o arquivo do S3 para a mem√≥ria
    const fileData = await downloadFileFromS3(fileName);
    
    // Envia o arquivo para o FTP a partir do arquivo tempor√°rio
    const uploadResult = await uploadFileToFtp(fileData, fileName);
    
    console.log('Processo de transfer√™ncia conclu√≠do com sucesso');
    return {
      success: true,
      message: `Arquivo ${fileName} transferido com sucesso para ${uploadResult.remotePath} com o novo nome ${uploadResult.renamedTo}`
    };
  } catch (error) {
    console.error('Erro durante o processo de transfer√™ncia:', error);
    return {
      success: false,
      message: `Erro durante a transfer√™ncia: ${error.message}`
    };
  }
}

// Fun√ß√£o para iniciar a tarefa agendada
function setupScheduler() {
  console.log(`Configurando job agendado com cron: ${config.cronSchedule}`);

  // Registra a tarefa agendada usando cron
  cron.schedule(config.cronSchedule, async () => {
    console.log(`Executando job agendado em ${new Date().toISOString()}`);
    try {
      const result = await transferDailyFileFromS3ToFtp();
      console.log(`Job agendado conclu√≠do com status: ${result.success ? 'Sucesso' : 'Falha'}`);
    } catch (error) {
      console.error('Erro ao executar job agendado:', error);
      await sendSlackAlert(`Erro ao executar job agendado: ${error.message}`);
    }
  }, {
    scheduled: true,
    timezone: 'America/Sao_Paulo' // Configura para o fuso hor√°rio do Brasil
  });
  
  console.log('Job agendado configurado com sucesso');
}

// Fun√ß√£o principal
async function main() {
  // Configura o scheduler com o cron
  setupScheduler();
  
  // Se configurado para rodar na inicializa√ß√£o, executa uma vez
  if (config.runOnStart) {
    console.log('Executando transfer√™ncia inicial...');
    try {
      const result = await transferDailyFileFromS3ToFtp();
      console.log('Resultado da transfer√™ncia inicial:', result);
    } catch (error) {
      console.error('Erro na transfer√™ncia inicial:', error);
    }
  }
  
  // Mant√©m o processo rodando
  console.log('Worker est√° rodando e aguardando pr√≥ximas execu√ß√µes agendadas...');
}

// Inicia o worker
main().catch(error => {
  console.error('Erro fatal no worker:', error);
  process.exit(1);
});
